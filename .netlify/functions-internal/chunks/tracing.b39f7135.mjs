const id = "tracing.md";
						const collection = "blog";
						const slug = "tracing";
						const body = "\nTracing can be a good tool to gain in-depth insights in problems you might have in your application. Why does this call take so long? What caused this specific error? Where in my distributed system did the process stop? Tracing be a tool to find out some of these causes.\n\nI used a specific set of tools to gain these insights. To be more specific:\n\n- OpenTracing which provides a tracing implentation in Java\n- ZIO for running effects and propagate to the right `Span`\n- cats-tagless for transforming tagless final interfaces to provide instrumented versions\n\nHow does a trace look like ? In Datadog it looks like this\n\n![Example of a trace](/img/blog/tracing/trace.jpg)\n\n\n## OpenTracing\n\n> OpenTracing is comprised of an API specification, frameworks and libraries that have implemented the specification, and documentation for the project. OpenTracing allows developers to add instrumentation to their application code using APIs that do not lock them into any one particular product, programming language or vendor.\n\nThe most important concept of OpenTracing is a `Span`. A `Span` represent a unit of work, you can attach tags or logs to a spawn and it has a start and end time. You can nest `Span` inside eachother, such that you can see what's going on.\n\n## ZIO\n\nZIO is library for modelling (a)synchronous effects inside your application. Typically a tracing application relies on `ThreadLocal` of Java to keep the current `Span`. However in ZIO you don't have that and you can use a `FiberRef` which allows you to store a local `Span`.\n\nA very simple implementation could look like this:\n\n```scala\ntrait Backend {\n  def root(operationName: String): UIO[Span]\n  def child(operationName: String, parent: Span): UIO[Span]\n  def close(span: Span): UIO[Unit]\n}\n\nobject Backend {\n  def opentracing(tracer: Tracer): Backend = new Backend {\n\n    def root(operationName: String): UIO[Span] =\n      UIO(tracer.buildSpan(operationName).start())\n\n    def child(operationName: String, parent: Span): UIO[Span] =\n      UIO(tracer.buildSpan(operationName).asChildOf(parent).start())\n\n    def close(span: Span): UIO[Unit] = UIO(span.finish())\n  }\n}\n\n\ntrait Tracing {\n  val tracing: Propagator\n}\n\nobject Tracing {\n  def apply(propagator: Propagator): Tracing = new Tracing {\n    val tracing: Propagator = propagator\n  }\n}\n\nclass Propagator(backend: Backend, ref: FiberRef[Span]) { self =>\n  def get: UIO[Span] = ref.get\n  def useChild[R, E, A](operationName: String, use: ZIO[R, E, A]): ZIO[R, E, A] =\n    ZIO.bracket(get.flatMap(backend.child(operationName, _)))(backend.close) { span =>\n      ref.locally(span)(use).provide(Tracing(self)))\n    }\n}\n\nobject Propagator {\n  def make(backend: Backend, initial: Span): UIO[Propagator] =\n    FiberRef.make(initial).map(new Propagator(backend, _))\n}\n\n```\n\nThe most important method here is the `useChild` method on `Propagator`. It uses `bracket` to run an computation. The allocate will start a new `Span` and after running the computation it will finish the current `Span`.\n\nOn every HTTP we receive we create a `Propagator` like this. I've used http4s:\n\n```scala\ndef trace(name: String)(operation: Propagator => Task[Response[Task]]): Task[Response[Task]] =\n    for {\n      tracer     <- UIO(OpenTracing.tracer)\n      rootSpan   <- UIO(tracer.buildSpan(name).start())\n      propagator <- Propagator.make(Backend.opentracing(tracer), rootSpan)\n      resp       <- operation(propagator).ensuring(UIO(rootSpan.finish()))\n    } yield resp\n```\n\nIn my backend I don't use Tapir or any endpoints library, but if you do you can generate the name of each transaction by generating an endpoint name.\n\nAn example of running a service method which is bound to an http4s endpoint looks like this.\n\n```scala\nval unsecured: HttpRoutes[Task] = HttpRoutes.of {\n    case GET -> Root :? CityMatcher(city) +& PostalCodeMatcher(postalCode) =>\n      trace(\"GET /geo\") { prop =>\n        GeoService.lookup(postalCode, city).provide(env.withTracing(prop)).flatMap(Ok(_))\n      }\n  }\n```\n\nTo actually trace something in our service methods we need to have access to the `Propagator`. The `Tracing` provides that dependency. So I've defined a _convenient_ alias for this:\n\n```scala\ntype Traced[+A] = RIO[Tracing, A]\n```\n\nWe eliminate the need of the dependencies by calling the `provide` method of `ZIO`. The dependencies are defined with a cake pattern. The signature of the `GeoService.lookup` method looks like this:\n\n```scala\ndef lookup(postalCode: Option[String], city: Option[String]): RIO[AddressClient.Component[Traced] with Tracing, Location]\n```\n\n\nFor example if you would require database access, you would include `Postgres`. As you can see the client for talking to an address API is included as well. Actually my `Postgres` trait extends `Tracing`. All the calls to the repositories are of `Traced`. The `env` instance here is actually a case class which implements all the dependencies defined in the application.\n\nThe default `Tracing` implementation uses a `NoopBackend` which is overriden by the `withTracing` (which is just a simple case class copy).\n\nSo what does cats-tagless has to do with this?\n\n## cats-tagless\n\ncats-tagless provides powerful macros to work with tagless final algebras.\n\n### Why?\n\nWhy would you bother using tagless final when you have ZIO ?\n\nI like to use tagless final algebras for the side-effectful components of my systems because it allows you to write down abstractly a effectful method, without getting to specific on the effect type of the method.\n\nI always implemenent the algebra with the least powerful abstraction, such that it stays flexible to swap any effect you would like. This means using `MonadError` or `Applicative` as effect constraint.\n\nUsing the least powerful abstraction makes your program less concerned about other stuff. It will only be able to `flatMap` and throw an error. The power ZIO provides is not used yet.\n\nDelaying the use of ZIO allows us to write laws of our algebras and more importantly deal with other concerns at a higher level. These concerns are:\n\n- Circuit breaking\n- Tracing\n- Metrics\n- Logging\n\nI explain how to apply tracing in this blog, but you could very well use this approach for logging or metrics as well.\n\n### Tracing ConnectionIO\n\nFor example, all my repositories (which are tagless final algebras) are implemented in terms of `ConnectionIO` from Doobie. Why?\n\n1. You can compose `ConnectionIO` to create transactions\n2. You can lawfully test the repositories by running multiple `ConnectionIO` statements, get the result and rollback the transaction to not even affect your database.\n3. With cats-tagless you can transform the complete tagless final algebra by using `FunctorK` to a ZIO `Task` or `Traced` which we use.\n\n\nThe repositories are transformed in the following steps\n\n![Natural transformations used to transform an algebra](/img/blog/tracing/effect_transform.png)\n\nNow every method call to a Repository includes the name of the algebra and the method name. I've used a specialized `Transactor` which includes the SQL statements and also traces how long a query takes.\n\nHow does that translate to code?\n\n```scala\n@autoFunctorK\n@autoInstrument\ntrait Locks[F[_]] {\n  def acquire(host: String, service: String): F[Int]\n}\n```\n\nThe code which explains the steps to transform\n\n```scala\n// Repository implementation in terms of ConnectionIO\nval doobie: Locks[ConnectionIO] = ???\n\n// The natural transformation which transforms ConnectionIO to Traced\nval xa: ConnectionIO ~> Traced = TracedTransactor.trans\n\n// Transform the ConnectionIO repository to a Traced implementation\nval traced: Locks[Traced] = doobie.mapK(xa)\n\n// The natural transformation to include a `Span` and operationName\nval instrumentToTraced: (Instrumentation[Traced, *] ~> Traced) =\n\tnew (Instrumentation[Traced, *] ~> Traced) {\n\t\tdef apply[A](fa: Instrumentation[Traced, A]): Traced[A] =\n\t\t  ZIO.accessM(_.tracing.useChild(show\"${fa.algebraName}.${fa.methodName}\", fa.value))\n\t}\n\n// The instrumented version by using the Instrument macro and apply the instrumentToTraced\nval instrumented: Locks[Traced] = traced.instrument.mapK(instrumentToTraced)\n```\n\n## Tracing HTTP\n\nI also use tagless final for interacting with external API's such as Keycloak. In Scala I use keycloak4s, which offers a extensive API built upon sttp. The nice thing about sttp is that you can plugin your own backends. I build a custom backend which works with the `Traced` effect such that HTTP calls can be traced accross multiple services.\n\n```scala\nclass TracingSttp(other: SttpBackend[Traced, Nothing]) extends SttpBackend[Traced, Nothing] {\n\n  def send[T](request: Request[T, Nothing]): Traced[Response[T]] = {\n    def action = {\n\n      def prepareTags: Traced[Unit] =\n        tag(\n          \"span.kind\"   -> \"client\",\n          \"http.method\" -> request.method.m,\n          \"http.url\"    -> request.uri.toString()\n        )\n\n      def extractHttpHeadersFromSpanContext: Traced[Map[String, String]] =\n        ZIO.accessM(_.tracing.httpHeaders)\n\n      for {\n        _       <- prepareTags\n        headers <- extractHttpHeadersFromSpanContext\n        resp    <- other.send(request.headers(headers))\n        _       <- tag(\"http.status_code\" -> resp.code)\n      } yield resp\n    }\n\n    action.instrumented(show\"${request.method.m} ${request.uri.path.mkString(\"/\")}\")\n  }\n\n  def close(): Unit = other.close()\n\n  def responseMonad: MonadError[Traced] = implicitly[MonadError[Traced]]\n\n}\n```\n\nYou can continue your trace accross asynchronous boundaries by encoding the trace id in the HTTP headers and decode it when you process the request on the other end. This also works with Kafka, you could add the tracing state inside a header of Kafka envelope. There are more integrations, this will also work for gRPC for example, checkout the opentracing-contrib.\n\n## Closing words\n\nTracing is a nice tool to do root cause analysis and find bottlenecks. OpenTracing, a standard implemented in multiple languages along with ZIO's `FiberRef` and cats-tagless can be used to build a non-intrusive way of adding tracing to your application.\n\nCredits to Tamer Abdulradi for his work on [zio-instrumentation](https://github.com/tabdulradi/zio-instrumentation) which has been a huge inspiration.\n";
						const data = {title:"Tracing with cats-tagless and ZIO",description:"Tracing can be a good tool to gain in-depth insights in problems you might have in your application.",banner:"\u002Fimg\u002Fblog\u002Ftracing\u002Ftrace.jpg",pubDate:new Date(1580774400000)};
						const _internal = {
							filePath: "/Users/mark/Projects/Personal/markdejong.org/src/content/blog/tracing.md",
							rawData: "\npubDate: \"2020-02-04\"\nbanner: \"/img/blog/tracing/trace.jpg\"\ntitle: \"Tracing with cats-tagless and ZIO\"\ndescription: \"Tracing can be a good tool to gain in-depth insights in problems you might have in your application.\"",
						};

export { _internal, body, collection, data, id, slug };
