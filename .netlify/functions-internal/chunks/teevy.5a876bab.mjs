const id = "teevy.md";
						const collection = "blog";
						const slug = "teevy";
						const body = "\nIn 2016 I joined a few friends who were working on a little hobby project. We were creating a website that allowed you to track the progression of your favorite television series. The project was called Teevy.\n\n![A logged in user at teevy.co](/img/blog/teevy/teevy_webapp.png)\n\nThe goal was to develop a Minimal Viable Product (MVP) first. We had no real business model for it, we were just passionate about what we do and this was just a hobby project for us to try new things.\n\nIn the next few minutes, I want to tell you about my journey creating a REST/JSON backend for Teevy with a pure functional programming language called Haskell.\n\n## Haskell, a pure functional programming language\n\nHaskell, you say? Yes, Haskell. I didn't know that much Haskell at that time. I read some books about it, and I just wanted to give it a go and *learn* it by applying it. So what are some nice properties of functional programming and Haskell?\n\n### Types\nTypes are an important recipe for Haskell and functional programming. They allow us to exactly capture what a function should accept as input and will give as output. They also describe how data structures look like.\n\nTypes can assure you that you are using the right shapes. This is, in fact, some sort of test. Some languages remove the need for a lot of tests by using expressive types (for example vectors and matrices which have their dimensions included in the type). Also, typing makes refactoring a lot easier, since the compiler will tell you when you are using the wrong shape.\n\nOpposed to dynamic languages which will let you know that you've made an error at runtime. To cover that usually, a lot of tests are written (which also need to be refactored after a refactoring) to avoid such errors.\n\n### Side effects\nIn pure functional programming, all (side) effects are captured and are handled explicitly. Examples of effects are optional values (Option/Maybe), asynchronous values (IO/Future/Task), disjunction values (Either), concurrent values (STM), modification of values, etc.\n\nThe advantage is that you will handle all effects explicitly and therefore it reduces the risk of having a bug in your program. A well-known problem with a C# and Java programs is having the null pointer exception at runtime in your program. In that case, the program references to an unset reference in memory, causing the program to terminate. This might be okay if you have set up an exception handler, but mapping this error to a good human-readable error requires you rethrow exceptions and write lots of boilerplate. And what if you have two or more potential null cases in your program? Yes, it will be a mess. Also, these functions which do not handle these side effects explicitly do not compose.\n\nWhat do I mean by this? Programs **without** explicit side effects can do things in between which might not give the same outcome every time. A pure expression like `1 + 1` will output `2` every time. In other words, create programs that are a bunch of expressions instead of a bunch of statements. Expressions compose!\n\n### Type classes\nA type class is a common structure, like an interface. But it is ad-hoc (that's why we call it a type class instance) and can abstract over high-kinded types (`Maybe a` is a higher kinded type, it takes one type parameter to create a fully constructed type).\n\nThe most well-known type classes in Haskell and functional programming are Functor, Monoid, Monad, Applicative, etc.\n\nFor example, we can have a Functor (which offers a map function) instance for an optional value and asynchronous values.\n\n### Composition, composition and composition\nEverywhere you look in functional programming, you will see **composition**. Functions compose, functors compose, applicatives compose, lenses compose, natural transformations compose, contravariant functors compose, etc. When you dig deeper you'll see it everywhere. In the end, when we are programming we decompose problems in small parts and compose them together to form a program.\n\n### The ecosystem\nAlmost all libraries written in Haskell can be found on [hackage](http://hackage.haskell.org/). Ranging from database drivers, web servers, parser libraries to numerical computing. Also, the documentation of any library is very easy to comprehend. Some libraries I've used for Teevy are:\n\n- Aeson: JSON encoding/decoding\n- Postgresql-simple: Database access\n- Scotty: Sinatra-like web framework\n- Configurator: For loading configuration\n- JWT: JSON Web Tokens for authentication\n\nYou can use cabal to install these packages, which I did back then. Nowadays you would use something like stack to manage your build (which uses cabal underneath).\n\n## Creating a web service\n\nSo what do we need to build a _simple_ web service?\n\n- Web server\n- JSON encoding/decoding\n- Database access\n- Loading a configuration file\n\nLet's start with the data part.\n\n### Dealing with data\n\nTo create a web service, you'll need to define data types and create type class instances which can:\n\n- Encode/decode JSON\n- Persist these types to database\n- Load data from the database\n\n#### Our data\n\nLet's pretend we are dealing with a user, just to keep things simple. Here's the definition of the user data record.\n\n```haskell\ndata User = User { name :: String, fileQuota :: Int }\n```\n\n#### JSON\n\nI've used the [aeson](https://hackage.haskell.org/package/aeson) library to work with JSON. An example of a JSON decoder type class instance for a user looks like this (if you write it out by hand).\n\n```haskell\ninstance FromJSON User where\n    parseJSON (Object v) = User <$>\n                           v .: \"name\" <*>\n                           v .: \"fileQuota\"\n    -- A non-Object value is of the wrong type, so fail.\n    parseJSON _          = empty\n```\n\nThe symbols `<$>` and `<*>` are just functions. I won't go much into detail, but these functions are related to Functor and Applicative constructs in functional programming. Aeson and Haskell can automatically derive the type class instance for the type `User`. Removing the need to write this boilerplate. Something like this:\n\n```haskell\ninstance FromJSON User\n```\n\nFinally we can use a `decode` function defined as `decode :: FromJSON a => ByteString -> Maybe a`. As you can see the generic parameter `a` requires you to have type class instance in scope of `FromJSON`. If that's the case, it will take `ByteString` and converts it into an optional value `Maybe a`.\n\nThis a great example of type classes (decoder type class) and explicit effects (returning an optional value).\n\n#### Database\n\nWe can also do the type class stuff for database access (using [postgres-simple](https://hackage.haskell.org/package/postgresql-simple)). Like this:\n\n```haskell\ninstance FromRow User where\n    fromRow = User <$> field <*> field\n```\n\nThe `FromRow` type class will extract columns from a result set and put them into a record. Selecting the right fields and the order of the fields in the query is important!\n\nBy supplying a instance of `FromRow` for the type `User` we can use it with `query_ :: FromRow r => Connection -> Query -> IO [r]`. As you can see it requires a `FromRow` type class instance again for `r`. If that's settled, we can supply a `Connection` and `Query`. It will give us back an `IO [r]` which is a list of `r` values.\n\nUsing this we can query the database. Like so:\n\n```haskell\nallUsers :: Connection -> IO [User]\nallUsers conn = query_ conn \"select * from user\"\n```\n\n### Scotty\n[Scotty](https://hackage.haskell.org/package/scotty) is a Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp. A small example from their website:\n\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Web.Scotty\n\nimport Data.Monoid (mconcat)\n\nmain = scotty 3000 $ do\n  get \"/:word\" $ do\n    beam <- param \"word\"\n    html $ mconcat [\"<h1>Scotty, \", beam, \" me up!</h1>\"]\n```\n\nThis will host a scotty server at port 3000. When you enter `localhost:3000/mark` it will print you `\"<h1>Scotty, mark me up!</h1>\"`\n\nQuite simple huh? (except the monoid stuff if you haven't seen it, but its just concat stuff really (with some laws)). In a few lines of code we've created a web service, how cool is that? :)\n\nTo output JSON we can use `json :: ToJSON a => a -> ActionM ()` instead of `html`. As you can see we need to have a `ToJSON` (encoder) type class instance in scope which is the opposite of `FromJSON` (decoder). I won't go into detail, but you can make an instance by using `instance ToJSON User`. For example, you could write `json fetchedUsers` where `fetchedUsers :: [User]` should return an array of users.\n\n### Config parsing\n\nEvery website nowadays has some configuration file which contains database connection strings, Facebook secrets, settings, etc. Haskell has a nice library to work with config files called: [configurator](https://hackage.haskell.org/package/configurator)\n\nIn the example below we load the properties using the configurator library:\n\n```haskell\ndata TvConfig = TvConfig {\n        teevyConnectInfo :: ConnectInfo\n    ,   teevyPort :: Int\n    ,   teevySecret :: T.Text\n    ,   tmdbApiKey :: TL.Text\n    ,   facebookSecret :: B.ByteString\n} deriving (Show, Eq)\n\nprocessDatabaseInfo :: Config -> IO (Maybe ConnectInfo)\nprocessDatabaseInfo cfg = do\n  host <- lookup cfg \"db.host\"\n  port <- lookup cfg \"db.port\"\n  db <- lookup cfg \"db.db\"\n  user <- lookup cfg \"db.user\"\n  pass <- lookup cfg \"db.pass\"\n  return (ConnectInfo <$> host <*> port <*> user <*> pass <*> db)\n\nprocessConfig :: Config -> IO (Maybe TvConfig)\nprocessConfig cfg = do\n  db <- processDatabaseInfo cfg\n  port <- lookup cfg \"teevy.port\"\n  secret <- lookup cfg \"teevy.secret\"\n  tmdbKey <- lookup cfg \"tmdb.key\"\n  fbSecret <- lookup cfg \"facebook.secret\"\n  return (TvConfig <$> db <*> port <*> secret <*> tmdbKey <*> fbSecret)\n\nloadConfig :: String -> IO (Maybe TvConfig)\nloadConfig path = do\n  exists <- doesFileExist path\n  if exists\n  then withLoad [Required path] processConfig\n  else return Nothing\n```\n\nThe takeaways here once again: simple functions, declarative parsing of the different sections and taking failure into account.\n\n## Conclusion\nI've learned a lot and some stuff can be greatly simplified or improved. Looking back at it, I am quite satisfied with what I have achieved. I learned a tremendous amount and I've created a nice MVP :)\n\nIt also proves that you can write REST backends with Haskell. Many other people have done it and they also like the advantages of it. Some complementary work can be found at:\n\n- [Making a website in Haskell](http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html)\n- [Building a JSON REST API in Haskell](http://taylor.fausak.me/2014/10/21/building-a-json-rest-api-in-haskell/)\n- [Engineering Silk](http://engineering.silk.co/)\n- [21 days of Hackage: scotty](https://ocharles.org.uk/blog/posts/2013-12-05-24-days-of-hackage-scotty.html)\n- [21 days of Hackage: postgres-simple](https://ocharles.org.uk/blog/posts/2012-12-03-postgresql-simple.html)\n- [21 days of Hackage: aeson](https://ocharles.org.uk/blog/posts/2012-12-07-24-days-of-hackage-aeson.html)\n- [21 days of Hackage: configurator](https://ocharles.org.uk/blog/posts/2012-12-21-24-days-of-hackage-configurator.html)\n\n\n## Learning Haskell\nTo learn Haskell, there are a few options. Like I have learned a lot from reading: [Learn you a Haskell for a Great Good](http://learnyouahaskell.com/), but it seems [Haskell programming](http://haskellbook.com/) gains more popularity lately.\n";
						const data = {title:"Building a REST\u002FJSON web service using a pure functional programming language",description:"Haskell in production: A REST\u002FJSON web service built with aeson, postgresql-simple, scotty and configurator.",banner:"\u002Fimg\u002Fblog\u002Fteevy\u002Fteevy_logo.png",pubDate:new Date(1464652800000)};
						const _internal = {
							filePath: "/Users/mark/Projects/Personal/markdejong.org/src/content/blog/teevy.md",
							rawData: "\npubDate: \"2016-05-31\"\nbanner: \"/img/blog/teevy/teevy_logo.png\"\ntitle: \"Building a REST/JSON web service using a pure functional programming language\"\ndescription: \"Haskell in production: A REST/JSON web service built with aeson, postgresql-simple, scotty and configurator.\"",
						};

export { _internal, body, collection, data, id, slug };
