const id = "saga.md";
						const collection = "blog";
						const slug = "saga";
						const body = "# Motivation for a `Saga`\n\nImagine you want to book a trip which includes a car, hotel, and a flight. If something cannot be booked, why would you bother going? If we would build this in Scala it would probably involve calling some external API's. These API's can go down, what happens if one of these API's is down?\n\n![Saga: example of a process which can fail, but takes failure into account](/img/blog/saga.png)\n\nYou could use `recover` to execute a _compensating_ action (an action which reverses the side-effect), but it will only work with _one_ action. Of course, you could apply this to all your actions, but this will get messy because you need to keep track of your compensating actions.\n\n# How to describe that nicely?\n\nTo describe a program that can handle failure you need to couple the outcome of a successful action to it's compensating action.\n\n## A short example of a `Saga` program\n\n```scala\nimport cats.effect.IO\nimport cats.implicits._\nimport cats.effect.concurrent.Ref\nimport goedverhaal._\nimport scala.util.control.NonFatal\n\ndef prg(ref: Ref[IO, Int]): Saga[IO, Unit] = for {\n  _ <- Saga.recoverable(ref.tryUpdate(_ + 1))(_ => ref.tryUpdate(_ - 1) *> IO.unit).replicateA(500)\n  _ <- Saga.recoverable(ref.tryUpdate(_ + 1))(_ => ref.tryUpdate(_ - 1) *> IO.unit).replicateA(500)\n  _ <- Saga.nonRecoverable[IO, Nothing](IO.raiseError(new Throwable(\"Error\")))\n} yield ()\n\ndef main: IO[Int] = for {\n  ref <- Ref.of[IO, Int](0)\n  _ <- prg(ref).run.recoverWith { case NonFatal(_) => IO.unit }\n  current <- ref.get\n} yield current\n```\n\nThe outcome of the main function will be zero, as the `prg` will crash at the end. The first action will increase the `Ref[IO, Int]` to 500 and the second action by another 500, but since it crashes the compensating actions will roll it back to 0.\n\n## The importance of lazy evaluation\n\nThe compensating action needs to be _description_ of an action. A description means, that's it is _not_ executed immediately (lazy evaluation) and it may be a side-effect. This is called a computation in functional programming. The opposite of lazy evaluation is eager evaluation. An example of a type which is eager is `Future` and `Try`.\n\n## Couple success with compensation\n\nIn my `Saga` the signature of the a _recoverable_ combinator is defined as:\n\n```scala\ndef recoverable[F[_] : Sync, A](comp: F[A])(rollback: A => F[Unit]): Saga[F, A]\n```\n\nThe type class `Sync` constrain on `F[_]` is to enforce a type which supports lazy evaluation. The thing we need for our description of a `Saga`. The function itself takes two arguments, an actual `comp` (short for computation) which is the *do* action, and the rollback which uses the outcome of the _do_ action to construct a rollback/compensating action.\n\n### Saga, a specialized `Free` Monad\n\nAs you can it returns a `Saga[F, A]`. A `Saga` itself is a description of several computations. In fact it's a slightly altered variant of a Free Monad:\n\n```scala\ncase class Pure[F[_], A](action: A) extends Saga[F, A]\ncase class Next[F[_], A](action: F[A], compensate: A => F[Unit]) extends Saga[F, A]\ncase class Bind[F[_], A, B](fa: Saga[F, A], f: A => Saga[F, B]) extends Saga[F, B]\n```\n\nThe `Pure` and `Bind` are descriptions of operations that you'll find on a `Monad` as well. The `Next` case, however, is not. This will store the parameters of the `recoverable` method as is for later evaluation.\n\nThis data is interpreted by the `decide` method on `Saga`, which looks like this:\n\n```scala\ndef decide[B](f: (A, List[F[Unit]]) => F[B]): F[B]\n```\n\nIt will fold the description of computations as described in the `Saga` data type to a `F[B]`. If anything fails (due a `Sync.onError`) it will execute the compensating actions accumulated so far. If it succeeds, it will execute the `f: (A, List[F[Unit]] => F[B]` function. This function lets you decide what to do with the outcome of the computation. This is useful when you work with an `EitherT` or `OptionT`. The outcome may be `None` or `Left`. In that case, you might want to rollback all the actions.\n\nYou can also use the `run` variant on `Saga` which uses the `decide`\n\n```scala\ndef run: F[A] = decide { case (a, _) => F.pure(a) }\n```\n\n# Conclusion\n\nAs you can see `Saga` is a useful tool when interacting with multiple API's which are crossing an asynchronous boundary and might not offer transactional guarantees. It might not be the best solution, but in a lot of cases you don't have a better choice I guess (welcome to the microservice/API era)!\n\nIf you want to have a closer look at how that's done or have feedback. Have a look at the source code on [Github](https://github.com/vectos/goedverhaal).\n\nActually someone developed a ZIO version of this: [zio-saga](https://github.com/VladKopanev/zio-saga)\n\nHappy hacking!\n";
						const data = {title:"Saga, compensate for failures in a terse and composable way",description:"This blog post is about Sagas, a pattern for managing failures.",banner:"\u002Fimg\u002Fblog\u002Fbanner_saga.jpg",pubDate:new Date(1533859200000)};
						const _internal = {
							filePath: "/Users/mark/Projects/Personal/markdejong.org/src/content/blog/saga.md",
							rawData: "\npubDate: \"2018-08-10\"\nbanner: \"/img/blog/banner_saga.jpg\"\ntitle: \"Saga, compensate for failures in a terse and composable way\"\ndescription: \"This blog post is about Sagas, a pattern for managing failures.\"",
						};

export { _internal, body, collection, data, id, slug };
