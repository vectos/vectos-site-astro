import { j as createVNode, s as spreadAttributes, F as Fragment } from './astro.360f122a.mjs';
import 'cookie';
import 'kleur/colors';
import 'slash';
import 'path-to-regexp';
import 'mime';
import 'html-escaper';
import 'string-width';

const images = {
					
				};

				function updateImageReferences(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="(.+)"/gm,
						(full, imagePath) => spreadAttributes({src: images[imagePath].src, ...images[imagePath].attributes})
					);
				}

				const html = updateImageReferences("<p>In 2016 I joined a few friends who were working on a little hobby project. We were creating a website that allowed you to track the progression of your favorite television series. The project was called Teevy.</p>\n<p><img src=\"/img/blog/teevy/teevy_webapp.png\" alt=\"A logged in user at teevy.co\"></p>\n<p>The goal was to develop a Minimal Viable Product (MVP) first. We had no real business model for it, we were just passionate about what we do and this was just a hobby project for us to try new things.</p>\n<p>In the next few minutes, I want to tell you about my journey creating a REST/JSON backend for Teevy with a pure functional programming language called Haskell.</p>\n<h2 id=\"haskell-a-pure-functional-programming-language\">Haskell, a pure functional programming language</h2>\n<p>Haskell, you say? Yes, Haskell. I didn’t know that much Haskell at that time. I read some books about it, and I just wanted to give it a go and <em>learn</em> it by applying it. So what are some nice properties of functional programming and Haskell?</p>\n<h3 id=\"types\">Types</h3>\n<p>Types are an important recipe for Haskell and functional programming. They allow us to exactly capture what a function should accept as input and will give as output. They also describe how data structures look like.</p>\n<p>Types can assure you that you are using the right shapes. This is, in fact, some sort of test. Some languages remove the need for a lot of tests by using expressive types (for example vectors and matrices which have their dimensions included in the type). Also, typing makes refactoring a lot easier, since the compiler will tell you when you are using the wrong shape.</p>\n<p>Opposed to dynamic languages which will let you know that you’ve made an error at runtime. To cover that usually, a lot of tests are written (which also need to be refactored after a refactoring) to avoid such errors.</p>\n<h3 id=\"side-effects\">Side effects</h3>\n<p>In pure functional programming, all (side) effects are captured and are handled explicitly. Examples of effects are optional values (Option/Maybe), asynchronous values (IO/Future/Task), disjunction values (Either), concurrent values (STM), modification of values, etc.</p>\n<p>The advantage is that you will handle all effects explicitly and therefore it reduces the risk of having a bug in your program. A well-known problem with a C# and Java programs is having the null pointer exception at runtime in your program. In that case, the program references to an unset reference in memory, causing the program to terminate. This might be okay if you have set up an exception handler, but mapping this error to a good human-readable error requires you rethrow exceptions and write lots of boilerplate. And what if you have two or more potential null cases in your program? Yes, it will be a mess. Also, these functions which do not handle these side effects explicitly do not compose.</p>\n<p>What do I mean by this? Programs <strong>without</strong> explicit side effects can do things in between which might not give the same outcome every time. A pure expression like <code>1 + 1</code> will output <code>2</code> every time. In other words, create programs that are a bunch of expressions instead of a bunch of statements. Expressions compose!</p>\n<h3 id=\"type-classes\">Type classes</h3>\n<p>A type class is a common structure, like an interface. But it is ad-hoc (that’s why we call it a type class instance) and can abstract over high-kinded types (<code>Maybe a</code> is a higher kinded type, it takes one type parameter to create a fully constructed type).</p>\n<p>The most well-known type classes in Haskell and functional programming are Functor, Monoid, Monad, Applicative, etc.</p>\n<p>For example, we can have a Functor (which offers a map function) instance for an optional value and asynchronous values.</p>\n<h3 id=\"composition-composition-and-composition\">Composition, composition and composition</h3>\n<p>Everywhere you look in functional programming, you will see <strong>composition</strong>. Functions compose, functors compose, applicatives compose, lenses compose, natural transformations compose, contravariant functors compose, etc. When you dig deeper you’ll see it everywhere. In the end, when we are programming we decompose problems in small parts and compose them together to form a program.</p>\n<h3 id=\"the-ecosystem\">The ecosystem</h3>\n<p>Almost all libraries written in Haskell can be found on <a href=\"http://hackage.haskell.org/\">hackage</a>. Ranging from database drivers, web servers, parser libraries to numerical computing. Also, the documentation of any library is very easy to comprehend. Some libraries I’ve used for Teevy are:</p>\n<ul>\n<li>Aeson: JSON encoding/decoding</li>\n<li>Postgresql-simple: Database access</li>\n<li>Scotty: Sinatra-like web framework</li>\n<li>Configurator: For loading configuration</li>\n<li>JWT: JSON Web Tokens for authentication</li>\n</ul>\n<p>You can use cabal to install these packages, which I did back then. Nowadays you would use something like stack to manage your build (which uses cabal underneath).</p>\n<h2 id=\"creating-a-web-service\">Creating a web service</h2>\n<p>So what do we need to build a <em>simple</em> web service?</p>\n<ul>\n<li>Web server</li>\n<li>JSON encoding/decoding</li>\n<li>Database access</li>\n<li>Loading a configuration file</li>\n</ul>\n<p>Let’s start with the data part.</p>\n<h3 id=\"dealing-with-data\">Dealing with data</h3>\n<p>To create a web service, you’ll need to define data types and create type class instances which can:</p>\n<ul>\n<li>Encode/decode JSON</li>\n<li>Persist these types to database</li>\n<li>Load data from the database</li>\n</ul>\n<h4 id=\"our-data\">Our data</h4>\n<p>Let’s pretend we are dealing with a user, just to keep things simple. Here’s the definition of the user data record.</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #ffffff; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #CF222E\">data</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">User</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">=</span><span style=\"color: #24292F\"> </span><span style=\"color: #0550AE\">User</span><span style=\"color: #24292F\"> { name </span><span style=\"color: #CF222E\">::</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">String</span><span style=\"color: #24292F\">, fileQuota </span><span style=\"color: #CF222E\">::</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">Int</span><span style=\"color: #24292F\"> }</span></span></code></pre>\n<h4 id=\"json\">JSON</h4>\n<p>I’ve used the <a href=\"https://hackage.haskell.org/package/aeson\">aeson</a> library to work with JSON. An example of a JSON decoder type class instance for a user looks like this (if you write it out by hand).</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #ffffff; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #CF222E\">instance</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">FromJSON</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">User</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">where</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">    parseJSON (</span><span style=\"color: #0550AE\">Object</span><span style=\"color: #24292F\"> v) </span><span style=\"color: #CF222E\">=</span><span style=\"color: #24292F\"> </span><span style=\"color: #0550AE\">User</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">&#x3C;$></span></span>\n<span class=\"line\"><span style=\"color: #24292F\">                           v </span><span style=\"color: #CF222E\">.:</span><span style=\"color: #24292F\"> </span><span style=\"color: #0A3069\">\"name\"</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">&#x3C;*></span></span>\n<span class=\"line\"><span style=\"color: #24292F\">                           v </span><span style=\"color: #CF222E\">.:</span><span style=\"color: #24292F\"> </span><span style=\"color: #0A3069\">\"fileQuota\"</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">    </span><span style=\"color: #6E7781\">-- A non-Object value is of the wrong type, so fail.</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">    parseJSON _          </span><span style=\"color: #CF222E\">=</span><span style=\"color: #24292F\"> empty</span></span></code></pre>\n<p>The symbols <code>&#x3C;$></code> and <code>&#x3C;*></code> are just functions. I won’t go much into detail, but these functions are related to Functor and Applicative constructs in functional programming. Aeson and Haskell can automatically derive the type class instance for the type <code>User</code>. Removing the need to write this boilerplate. Something like this:</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #ffffff; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #CF222E\">instance</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">FromJSON</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">User</span></span></code></pre>\n<p>Finally we can use a <code>decode</code> function defined as <code>decode :: FromJSON a => ByteString -> Maybe a</code>. As you can see the generic parameter <code>a</code> requires you to have type class instance in scope of <code>FromJSON</code>. If that’s the case, it will take <code>ByteString</code> and converts it into an optional value <code>Maybe a</code>.</p>\n<p>This a great example of type classes (decoder type class) and explicit effects (returning an optional value).</p>\n<h4 id=\"database\">Database</h4>\n<p>We can also do the type class stuff for database access (using <a href=\"https://hackage.haskell.org/package/postgresql-simple\">postgres-simple</a>). Like this:</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #ffffff; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #CF222E\">instance</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">FromRow</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">User</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">where</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">    fromRow </span><span style=\"color: #CF222E\">=</span><span style=\"color: #24292F\"> </span><span style=\"color: #0550AE\">User</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">&#x3C;$></span><span style=\"color: #24292F\"> field </span><span style=\"color: #CF222E\">&#x3C;*></span><span style=\"color: #24292F\"> field</span></span></code></pre>\n<p>The <code>FromRow</code> type class will extract columns from a result set and put them into a record. Selecting the right fields and the order of the fields in the query is important!</p>\n<p>By supplying a instance of <code>FromRow</code> for the type <code>User</code> we can use it with <code>query_ :: FromRow r => Connection -> Query -> IO [r]</code>. As you can see it requires a <code>FromRow</code> type class instance again for <code>r</code>. If that’s settled, we can supply a <code>Connection</code> and <code>Query</code>. It will give us back an <code>IO [r]</code> which is a list of <code>r</code> values.</p>\n<p>Using this we can query the database. Like so:</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #ffffff; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #8250DF\">allUsers</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">::</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">Connection</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">-></span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">IO</span><span style=\"color: #24292F\"> [</span><span style=\"color: #CF222E\">User</span><span style=\"color: #24292F\">]</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">allUsers conn </span><span style=\"color: #CF222E\">=</span><span style=\"color: #24292F\"> query_ conn </span><span style=\"color: #0A3069\">\"select * from user\"</span></span></code></pre>\n<h3 id=\"scotty\">Scotty</h3>\n<p><a href=\"https://hackage.haskell.org/package/scotty\">Scotty</a> is a Haskell web framework inspired by Ruby’s Sinatra, using WAI and Warp. A small example from their website:</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #ffffff; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #24292F\">{-# </span><span style=\"color: #CF222E\">LANGUAGE</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">OverloadedStrings</span><span style=\"color: #24292F\"> #-}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #CF222E\">import</span><span style=\"color: #24292F\"> </span><span style=\"color: #953800\">Web.Scotty</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #CF222E\">import</span><span style=\"color: #24292F\"> </span><span style=\"color: #953800\">Data.Monoid</span><span style=\"color: #24292F\"> (</span><span style=\"color: #8250DF\">mconcat</span><span style=\"color: #24292F\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #24292F\">main </span><span style=\"color: #CF222E\">=</span><span style=\"color: #24292F\"> scotty </span><span style=\"color: #0550AE\">3000</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">$</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">do</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  get </span><span style=\"color: #0A3069\">\"/:word\"</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">$</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">do</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">    beam </span><span style=\"color: #CF222E\">&#x3C;-</span><span style=\"color: #24292F\"> param </span><span style=\"color: #0A3069\">\"word\"</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">    html </span><span style=\"color: #CF222E\">$</span><span style=\"color: #24292F\"> mconcat [</span><span style=\"color: #0A3069\">\"&#x3C;h1>Scotty, \"</span><span style=\"color: #24292F\">, beam, </span><span style=\"color: #0A3069\">\" me up!&#x3C;/h1>\"</span><span style=\"color: #24292F\">]</span></span></code></pre>\n<p>This will host a scotty server at port 3000. When you enter <code>localhost:3000/mark</code> it will print you <code>\"&#x3C;h1>Scotty, mark me up!&#x3C;/h1>\"</code></p>\n<p>Quite simple huh? (except the monoid stuff if you haven’t seen it, but its just concat stuff really (with some laws)). In a few lines of code we’ve created a web service, how cool is that? :)</p>\n<p>To output JSON we can use <code>json :: ToJSON a => a -> ActionM ()</code> instead of <code>html</code>. As you can see we need to have a <code>ToJSON</code> (encoder) type class instance in scope which is the opposite of <code>FromJSON</code> (decoder). I won’t go into detail, but you can make an instance by using <code>instance ToJSON User</code>. For example, you could write <code>json fetchedUsers</code> where <code>fetchedUsers :: [User]</code> should return an array of users.</p>\n<h3 id=\"config-parsing\">Config parsing</h3>\n<p>Every website nowadays has some configuration file which contains database connection strings, Facebook secrets, settings, etc. Haskell has a nice library to work with config files called: <a href=\"https://hackage.haskell.org/package/configurator\">configurator</a></p>\n<p>In the example below we load the properties using the configurator library:</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #ffffff; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #CF222E\">data</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">TvConfig</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">=</span><span style=\"color: #24292F\"> </span><span style=\"color: #0550AE\">TvConfig</span><span style=\"color: #24292F\"> {</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">        teevyConnectInfo </span><span style=\"color: #CF222E\">::</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">ConnectInfo</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">    ,   teevyPort </span><span style=\"color: #CF222E\">::</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">Int</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">    ,   teevySecret </span><span style=\"color: #CF222E\">::</span><span style=\"color: #24292F\"> </span><span style=\"color: #953800\">T.</span><span style=\"color: #CF222E\">Text</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">    ,   tmdbApiKey </span><span style=\"color: #CF222E\">::</span><span style=\"color: #24292F\"> </span><span style=\"color: #953800\">TL.</span><span style=\"color: #CF222E\">Text</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">    ,   facebookSecret </span><span style=\"color: #CF222E\">::</span><span style=\"color: #24292F\"> </span><span style=\"color: #953800\">B.</span><span style=\"color: #CF222E\">ByteString</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">} </span><span style=\"color: #CF222E\">deriving</span><span style=\"color: #24292F\"> (</span><span style=\"color: #CF222E\">Show</span><span style=\"color: #24292F\">, </span><span style=\"color: #CF222E\">Eq</span><span style=\"color: #24292F\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #8250DF\">processDatabaseInfo</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">::</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">Config</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">-></span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">IO</span><span style=\"color: #24292F\"> (</span><span style=\"color: #CF222E\">Maybe</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">ConnectInfo</span><span style=\"color: #24292F\">)</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">processDatabaseInfo cfg </span><span style=\"color: #CF222E\">=</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">do</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  host </span><span style=\"color: #CF222E\">&#x3C;-</span><span style=\"color: #24292F\"> lookup cfg </span><span style=\"color: #0A3069\">\"db.host\"</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  port </span><span style=\"color: #CF222E\">&#x3C;-</span><span style=\"color: #24292F\"> lookup cfg </span><span style=\"color: #0A3069\">\"db.port\"</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  db </span><span style=\"color: #CF222E\">&#x3C;-</span><span style=\"color: #24292F\"> lookup cfg </span><span style=\"color: #0A3069\">\"db.db\"</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  user </span><span style=\"color: #CF222E\">&#x3C;-</span><span style=\"color: #24292F\"> lookup cfg </span><span style=\"color: #0A3069\">\"db.user\"</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  pass </span><span style=\"color: #CF222E\">&#x3C;-</span><span style=\"color: #24292F\"> lookup cfg </span><span style=\"color: #0A3069\">\"db.pass\"</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  return (</span><span style=\"color: #0550AE\">ConnectInfo</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">&#x3C;$></span><span style=\"color: #24292F\"> host </span><span style=\"color: #CF222E\">&#x3C;*></span><span style=\"color: #24292F\"> port </span><span style=\"color: #CF222E\">&#x3C;*></span><span style=\"color: #24292F\"> user </span><span style=\"color: #CF222E\">&#x3C;*></span><span style=\"color: #24292F\"> pass </span><span style=\"color: #CF222E\">&#x3C;*></span><span style=\"color: #24292F\"> db)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #8250DF\">processConfig</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">::</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">Config</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">-></span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">IO</span><span style=\"color: #24292F\"> (</span><span style=\"color: #CF222E\">Maybe</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">TvConfig</span><span style=\"color: #24292F\">)</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">processConfig cfg </span><span style=\"color: #CF222E\">=</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">do</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  db </span><span style=\"color: #CF222E\">&#x3C;-</span><span style=\"color: #24292F\"> processDatabaseInfo cfg</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  port </span><span style=\"color: #CF222E\">&#x3C;-</span><span style=\"color: #24292F\"> lookup cfg </span><span style=\"color: #0A3069\">\"teevy.port\"</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  secret </span><span style=\"color: #CF222E\">&#x3C;-</span><span style=\"color: #24292F\"> lookup cfg </span><span style=\"color: #0A3069\">\"teevy.secret\"</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  tmdbKey </span><span style=\"color: #CF222E\">&#x3C;-</span><span style=\"color: #24292F\"> lookup cfg </span><span style=\"color: #0A3069\">\"tmdb.key\"</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  fbSecret </span><span style=\"color: #CF222E\">&#x3C;-</span><span style=\"color: #24292F\"> lookup cfg </span><span style=\"color: #0A3069\">\"facebook.secret\"</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  return (</span><span style=\"color: #0550AE\">TvConfig</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">&#x3C;$></span><span style=\"color: #24292F\"> db </span><span style=\"color: #CF222E\">&#x3C;*></span><span style=\"color: #24292F\"> port </span><span style=\"color: #CF222E\">&#x3C;*></span><span style=\"color: #24292F\"> secret </span><span style=\"color: #CF222E\">&#x3C;*></span><span style=\"color: #24292F\"> tmdbKey </span><span style=\"color: #CF222E\">&#x3C;*></span><span style=\"color: #24292F\"> fbSecret)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #8250DF\">loadConfig</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">::</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">String</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">-></span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">IO</span><span style=\"color: #24292F\"> (</span><span style=\"color: #CF222E\">Maybe</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">TvConfig</span><span style=\"color: #24292F\">)</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">loadConfig path </span><span style=\"color: #CF222E\">=</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">do</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  exists </span><span style=\"color: #CF222E\">&#x3C;-</span><span style=\"color: #24292F\"> doesFileExist path</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  </span><span style=\"color: #CF222E\">if</span><span style=\"color: #24292F\"> exists</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  </span><span style=\"color: #CF222E\">then</span><span style=\"color: #24292F\"> withLoad [</span><span style=\"color: #0550AE\">Required</span><span style=\"color: #24292F\"> path] processConfig</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">  </span><span style=\"color: #CF222E\">else</span><span style=\"color: #24292F\"> return </span><span style=\"color: #0550AE\">Nothing</span></span></code></pre>\n<p>The takeaways here once again: simple functions, declarative parsing of the different sections and taking failure into account.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>I’ve learned a lot and some stuff can be greatly simplified or improved. Looking back at it, I am quite satisfied with what I have achieved. I learned a tremendous amount and I’ve created a nice MVP :)</p>\n<p>It also proves that you can write REST backends with Haskell. Many other people have done it and they also like the advantages of it. Some complementary work can be found at:</p>\n<ul>\n<li><a href=\"http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html\">Making a website in Haskell</a></li>\n<li><a href=\"http://taylor.fausak.me/2014/10/21/building-a-json-rest-api-in-haskell/\">Building a JSON REST API in Haskell</a></li>\n<li><a href=\"http://engineering.silk.co/\">Engineering Silk</a></li>\n<li><a href=\"https://ocharles.org.uk/blog/posts/2013-12-05-24-days-of-hackage-scotty.html\">21 days of Hackage: scotty</a></li>\n<li><a href=\"https://ocharles.org.uk/blog/posts/2012-12-03-postgresql-simple.html\">21 days of Hackage: postgres-simple</a></li>\n<li><a href=\"https://ocharles.org.uk/blog/posts/2012-12-07-24-days-of-hackage-aeson.html\">21 days of Hackage: aeson</a></li>\n<li><a href=\"https://ocharles.org.uk/blog/posts/2012-12-21-24-days-of-hackage-configurator.html\">21 days of Hackage: configurator</a></li>\n</ul>\n<h2 id=\"learning-haskell\">Learning Haskell</h2>\n<p>To learn Haskell, there are a few options. Like I have learned a lot from reading: <a href=\"http://learnyouahaskell.com/\">Learn you a Haskell for a Great Good</a>, but it seems <a href=\"http://haskellbook.com/\">Haskell programming</a> gains more popularity lately.</p>");

				const frontmatter = {"pubDate":"2016-05-31","banner":"/img/blog/teevy/teevy_logo.png","title":"Building a REST/JSON web service using a pure functional programming language","description":"Haskell in production: A REST/JSON web service built with aeson, postgresql-simple, scotty and configurator."};
				const file = "/Users/mark/Projects/Personal/markdejong.org/src/content/blog/teevy.md";
				const url = undefined;
				function rawContent() {
					return "\nIn 2016 I joined a few friends who were working on a little hobby project. We were creating a website that allowed you to track the progression of your favorite television series. The project was called Teevy.\n\n![A logged in user at teevy.co](/img/blog/teevy/teevy_webapp.png)\n\nThe goal was to develop a Minimal Viable Product (MVP) first. We had no real business model for it, we were just passionate about what we do and this was just a hobby project for us to try new things.\n\nIn the next few minutes, I want to tell you about my journey creating a REST/JSON backend for Teevy with a pure functional programming language called Haskell.\n\n## Haskell, a pure functional programming language\n\nHaskell, you say? Yes, Haskell. I didn't know that much Haskell at that time. I read some books about it, and I just wanted to give it a go and *learn* it by applying it. So what are some nice properties of functional programming and Haskell?\n\n### Types\nTypes are an important recipe for Haskell and functional programming. They allow us to exactly capture what a function should accept as input and will give as output. They also describe how data structures look like.\n\nTypes can assure you that you are using the right shapes. This is, in fact, some sort of test. Some languages remove the need for a lot of tests by using expressive types (for example vectors and matrices which have their dimensions included in the type). Also, typing makes refactoring a lot easier, since the compiler will tell you when you are using the wrong shape.\n\nOpposed to dynamic languages which will let you know that you've made an error at runtime. To cover that usually, a lot of tests are written (which also need to be refactored after a refactoring) to avoid such errors.\n\n### Side effects\nIn pure functional programming, all (side) effects are captured and are handled explicitly. Examples of effects are optional values (Option/Maybe), asynchronous values (IO/Future/Task), disjunction values (Either), concurrent values (STM), modification of values, etc.\n\nThe advantage is that you will handle all effects explicitly and therefore it reduces the risk of having a bug in your program. A well-known problem with a C# and Java programs is having the null pointer exception at runtime in your program. In that case, the program references to an unset reference in memory, causing the program to terminate. This might be okay if you have set up an exception handler, but mapping this error to a good human-readable error requires you rethrow exceptions and write lots of boilerplate. And what if you have two or more potential null cases in your program? Yes, it will be a mess. Also, these functions which do not handle these side effects explicitly do not compose.\n\nWhat do I mean by this? Programs **without** explicit side effects can do things in between which might not give the same outcome every time. A pure expression like `1 + 1` will output `2` every time. In other words, create programs that are a bunch of expressions instead of a bunch of statements. Expressions compose!\n\n### Type classes\nA type class is a common structure, like an interface. But it is ad-hoc (that's why we call it a type class instance) and can abstract over high-kinded types (`Maybe a` is a higher kinded type, it takes one type parameter to create a fully constructed type).\n\nThe most well-known type classes in Haskell and functional programming are Functor, Monoid, Monad, Applicative, etc.\n\nFor example, we can have a Functor (which offers a map function) instance for an optional value and asynchronous values.\n\n### Composition, composition and composition\nEverywhere you look in functional programming, you will see **composition**. Functions compose, functors compose, applicatives compose, lenses compose, natural transformations compose, contravariant functors compose, etc. When you dig deeper you'll see it everywhere. In the end, when we are programming we decompose problems in small parts and compose them together to form a program.\n\n### The ecosystem\nAlmost all libraries written in Haskell can be found on [hackage](http://hackage.haskell.org/). Ranging from database drivers, web servers, parser libraries to numerical computing. Also, the documentation of any library is very easy to comprehend. Some libraries I've used for Teevy are:\n\n- Aeson: JSON encoding/decoding\n- Postgresql-simple: Database access\n- Scotty: Sinatra-like web framework\n- Configurator: For loading configuration\n- JWT: JSON Web Tokens for authentication\n\nYou can use cabal to install these packages, which I did back then. Nowadays you would use something like stack to manage your build (which uses cabal underneath).\n\n## Creating a web service\n\nSo what do we need to build a _simple_ web service?\n\n- Web server\n- JSON encoding/decoding\n- Database access\n- Loading a configuration file\n\nLet's start with the data part.\n\n### Dealing with data\n\nTo create a web service, you'll need to define data types and create type class instances which can:\n\n- Encode/decode JSON\n- Persist these types to database\n- Load data from the database\n\n#### Our data\n\nLet's pretend we are dealing with a user, just to keep things simple. Here's the definition of the user data record.\n\n```haskell\ndata User = User { name :: String, fileQuota :: Int }\n```\n\n#### JSON\n\nI've used the [aeson](https://hackage.haskell.org/package/aeson) library to work with JSON. An example of a JSON decoder type class instance for a user looks like this (if you write it out by hand).\n\n```haskell\ninstance FromJSON User where\n    parseJSON (Object v) = User <$>\n                           v .: \"name\" <*>\n                           v .: \"fileQuota\"\n    -- A non-Object value is of the wrong type, so fail.\n    parseJSON _          = empty\n```\n\nThe symbols `<$>` and `<*>` are just functions. I won't go much into detail, but these functions are related to Functor and Applicative constructs in functional programming. Aeson and Haskell can automatically derive the type class instance for the type `User`. Removing the need to write this boilerplate. Something like this:\n\n```haskell\ninstance FromJSON User\n```\n\nFinally we can use a `decode` function defined as `decode :: FromJSON a => ByteString -> Maybe a`. As you can see the generic parameter `a` requires you to have type class instance in scope of `FromJSON`. If that's the case, it will take `ByteString` and converts it into an optional value `Maybe a`.\n\nThis a great example of type classes (decoder type class) and explicit effects (returning an optional value).\n\n#### Database\n\nWe can also do the type class stuff for database access (using [postgres-simple](https://hackage.haskell.org/package/postgresql-simple)). Like this:\n\n```haskell\ninstance FromRow User where\n    fromRow = User <$> field <*> field\n```\n\nThe `FromRow` type class will extract columns from a result set and put them into a record. Selecting the right fields and the order of the fields in the query is important!\n\nBy supplying a instance of `FromRow` for the type `User` we can use it with `query_ :: FromRow r => Connection -> Query -> IO [r]`. As you can see it requires a `FromRow` type class instance again for `r`. If that's settled, we can supply a `Connection` and `Query`. It will give us back an `IO [r]` which is a list of `r` values.\n\nUsing this we can query the database. Like so:\n\n```haskell\nallUsers :: Connection -> IO [User]\nallUsers conn = query_ conn \"select * from user\"\n```\n\n### Scotty\n[Scotty](https://hackage.haskell.org/package/scotty) is a Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp. A small example from their website:\n\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Web.Scotty\n\nimport Data.Monoid (mconcat)\n\nmain = scotty 3000 $ do\n  get \"/:word\" $ do\n    beam <- param \"word\"\n    html $ mconcat [\"<h1>Scotty, \", beam, \" me up!</h1>\"]\n```\n\nThis will host a scotty server at port 3000. When you enter `localhost:3000/mark` it will print you `\"<h1>Scotty, mark me up!</h1>\"`\n\nQuite simple huh? (except the monoid stuff if you haven't seen it, but its just concat stuff really (with some laws)). In a few lines of code we've created a web service, how cool is that? :)\n\nTo output JSON we can use `json :: ToJSON a => a -> ActionM ()` instead of `html`. As you can see we need to have a `ToJSON` (encoder) type class instance in scope which is the opposite of `FromJSON` (decoder). I won't go into detail, but you can make an instance by using `instance ToJSON User`. For example, you could write `json fetchedUsers` where `fetchedUsers :: [User]` should return an array of users.\n\n### Config parsing\n\nEvery website nowadays has some configuration file which contains database connection strings, Facebook secrets, settings, etc. Haskell has a nice library to work with config files called: [configurator](https://hackage.haskell.org/package/configurator)\n\nIn the example below we load the properties using the configurator library:\n\n```haskell\ndata TvConfig = TvConfig {\n        teevyConnectInfo :: ConnectInfo\n    ,   teevyPort :: Int\n    ,   teevySecret :: T.Text\n    ,   tmdbApiKey :: TL.Text\n    ,   facebookSecret :: B.ByteString\n} deriving (Show, Eq)\n\nprocessDatabaseInfo :: Config -> IO (Maybe ConnectInfo)\nprocessDatabaseInfo cfg = do\n  host <- lookup cfg \"db.host\"\n  port <- lookup cfg \"db.port\"\n  db <- lookup cfg \"db.db\"\n  user <- lookup cfg \"db.user\"\n  pass <- lookup cfg \"db.pass\"\n  return (ConnectInfo <$> host <*> port <*> user <*> pass <*> db)\n\nprocessConfig :: Config -> IO (Maybe TvConfig)\nprocessConfig cfg = do\n  db <- processDatabaseInfo cfg\n  port <- lookup cfg \"teevy.port\"\n  secret <- lookup cfg \"teevy.secret\"\n  tmdbKey <- lookup cfg \"tmdb.key\"\n  fbSecret <- lookup cfg \"facebook.secret\"\n  return (TvConfig <$> db <*> port <*> secret <*> tmdbKey <*> fbSecret)\n\nloadConfig :: String -> IO (Maybe TvConfig)\nloadConfig path = do\n  exists <- doesFileExist path\n  if exists\n  then withLoad [Required path] processConfig\n  else return Nothing\n```\n\nThe takeaways here once again: simple functions, declarative parsing of the different sections and taking failure into account.\n\n## Conclusion\nI've learned a lot and some stuff can be greatly simplified or improved. Looking back at it, I am quite satisfied with what I have achieved. I learned a tremendous amount and I've created a nice MVP :)\n\nIt also proves that you can write REST backends with Haskell. Many other people have done it and they also like the advantages of it. Some complementary work can be found at:\n\n- [Making a website in Haskell](http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html)\n- [Building a JSON REST API in Haskell](http://taylor.fausak.me/2014/10/21/building-a-json-rest-api-in-haskell/)\n- [Engineering Silk](http://engineering.silk.co/)\n- [21 days of Hackage: scotty](https://ocharles.org.uk/blog/posts/2013-12-05-24-days-of-hackage-scotty.html)\n- [21 days of Hackage: postgres-simple](https://ocharles.org.uk/blog/posts/2012-12-03-postgresql-simple.html)\n- [21 days of Hackage: aeson](https://ocharles.org.uk/blog/posts/2012-12-07-24-days-of-hackage-aeson.html)\n- [21 days of Hackage: configurator](https://ocharles.org.uk/blog/posts/2012-12-21-24-days-of-hackage-configurator.html)\n\n\n## Learning Haskell\nTo learn Haskell, there are a few options. Like I have learned a lot from reading: [Learn you a Haskell for a Great Good](http://learnyouahaskell.com/), but it seems [Haskell programming](http://haskellbook.com/) gains more popularity lately.\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"haskell-a-pure-functional-programming-language","text":"Haskell, a pure functional programming language"},{"depth":3,"slug":"types","text":"Types"},{"depth":3,"slug":"side-effects","text":"Side effects"},{"depth":3,"slug":"type-classes","text":"Type classes"},{"depth":3,"slug":"composition-composition-and-composition","text":"Composition, composition and composition"},{"depth":3,"slug":"the-ecosystem","text":"The ecosystem"},{"depth":2,"slug":"creating-a-web-service","text":"Creating a web service"},{"depth":3,"slug":"dealing-with-data","text":"Dealing with data"},{"depth":4,"slug":"our-data","text":"Our data"},{"depth":4,"slug":"json","text":"JSON"},{"depth":4,"slug":"database","text":"Database"},{"depth":3,"slug":"scotty","text":"Scotty"},{"depth":3,"slug":"config-parsing","text":"Config parsing"},{"depth":2,"slug":"conclusion","text":"Conclusion"},{"depth":2,"slug":"learning-haskell","text":"Learning Haskell"}];
				}
				async function Content() {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;
					const contentFragment = createVNode(Fragment, { 'set:html': html });
					return contentFragment;
				}
				Content[Symbol.for('astro.needsHeadRendering')] = true;

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, images, rawContent, url };
